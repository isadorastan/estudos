### Estudando teorias üß†

Neste reposit√≥rio deixarei por escrito algumas quest√µes te√≥ricas que s√£o chatas, por√©m necess√°rias para a evolu√ß√£o profissional ü§™

### JS 
- [Como funciona o JS](#how-js-works)
- [O que √© o JS](#what-is-js)
- [Operadores](#operators)
- [Hoisting](#hosting)
- [Scope](#scope)
- [Nested Scopes](#nested-scopes)
- [Variables](#variables)
- [ES6 Features](#es6-features)
- [Pure Functions](#pure-functions)
- [Closure](#closure)
- [Currying](#currying)
- [Higher-Order Functions](#higher-order-functions)

#### <a name="how-js-works"></a> Como funciona o JS
O google chrome usa a engine v8 (open source escrita em c++) . A engine v8 serve para interpretar um c√≥digo javascript. 
A v8 foi projetada para aumentar a perfomance de execu√ß√£o do JS dentro de navegadores, ele compila c√≥digo JS em c√≥digo de maquina ao inv√©s de usar um interpretador. Ele compila de js para c√≥digo de m√°quina em tempo de execu√ß√£o, implementando um compilador JIT (just in time).

```JS => c++ => Assembly => Machine Code ```

#### <a name="what-is-js"></a> O que √© o JS
Javascript √© como n√≥s chamamos a linguaguem (mas isso √© o trademark da Oracle), o nome oficial da linguagem √© ECMAScript (ES) √© a abrevia√ß√£o. 

```ES6 === ECMAScript 6 === ES2015```, √© simplesmente a vers√£o *mais nova da linguagem (entre aspas)*.

 O que aconteceu √© que o ES5, n√£o √© de 2014.. mas sim de 1999. Isso mesmo, ficamos 16 anos sem updates. Basicamente porque n√£o era t√£o bom e existiam algumas alternativas, a mais famosa delas: o Flash. Em 2008 o google Chrome foi lan√ßado, e aclamado por sua perfomance na execu√ß√£o de javascript, o que iniciou uma guerra pelo desenvolvimento de interpretadores cada vez mais r√°pidos, o que deixou o chrome para tr√°s. At√© que foi lan√ßado em 2013, a nova vers√£o do chrome usando a V8, tornando-o novamente o mais r√°pido na execu√ß√£o de JS. Dois anos ap√≥s.. tivemos o ES6.

Suporte ES:
- O  **ECMAScript 3**  √© totalmente  **suportado**  em  **todos os navegadores**.
- O  **ECMAScript 5 (2009)**  √© totalmente  **suportado**  em  **todos os navegadores modernos**  .  **Observa√ß√£o**: O  **Internet Explorer 9 n√£o suporta ECMAScript 5**  `"use strict"`.
- O  **ECMAScript 6 (ECMAScript 2015)**  √© totalmente  **suportado**  em  **todos os navegadores modernos, menos no Internet Explorer.**
- O  **ECMAScript 7 (ECMAScript 2016)**  √© suportado  **apenas no Chrome e Opera.**

**NOTA:**  Observe sempre as  **vers√µes do browser**  e quais  **m√©todos**  s√£o  **compat√≠veis**  no  **mesmo**.

**Se nem todos os browsers suportam o ES6 como fazemos?**
por isso usamos transpilers como o BABEL. Ele transforma seu c√≥digo ES6 em ES5 (que a maioria dos browsers d√° suporte)

fontes:
- [https://medium.com/@matheusml/o-guia-do-es6-tudo-que-voc%C3%AA-precisa-saber-8c287876325f](https://medium.com/@matheusml/o-guia-do-es6-tudo-que-voc%C3%AA-precisa-saber-8c287876325f)
- [https://pt.wikipedia.org/wiki/Interpretador_de_JavaScript](https://pt.wikipedia.org/wiki/Interpretador_de_JavaScript)
- [https://pt.stackoverflow.com/questions/383174/o-ecmascript-6-%C3%A9-suportado-pelos-browsers-atuais](https://pt.stackoverflow.com/questions/383174/o-ecmascript-6-%C3%A9-suportado-pelos-browsers-atuais)

#### <a name="operators"></a> Operadores

## Operadores de compara√ß√£o
- Igual `==`  
- N√£o igual `!=`
- Estritamente igual `===`
- Estritamente n√£o igual `!==`
- Maior que `>` e maior igual 	que `>=`
- Menor que `<` e menor igual que `<=`

```javascript
const maioridade = 18;
const idade = 16;
console.log(idade >= maioridade); // false

1 == '1' // true
1 === '1' // false

1 != '1' // true
1 !== '1' // false
```

## Operadores aritm√©ticos
### M√≥dulo `%`
```javascript
// resto da divis√£o
const result = 12%5 // result = 2
```
### Incremento `++`
```javascript
// prefixado
let x = 3;
++x // retorna 4

// posfixado
let x = 3
x++ // retorna 3 depois define x como 4
```
### Decremento `--`
```javascript
// prefixado
let x = 3;
--x // retorna 2

// posfixado
let x = 3
x-- // retorna 2 depois define x como 2
```
### Nega√ß√£o `-`
```javascript
let x = 3;
-x // retorna -3
```
### Adi√ß√£o `+`
```javascript
// converte um operando em n√∫mero, sempre que poss√≠vel
+"3" // retorna 3
+true // retorna 1
```
### Exponencial `**`
```javascript
 let x = 2**3 // retorna 8
```

## Operadores de atribui√ß√£o
### Atribui√ß√£o
```javascript
	x = y
```
 ### Atribui√ß√£o matem√°ticos
```javascript
	x += y // x = x + y (adi√ß√£o)
	x -= y // x = x - y (subtra√ß√£o)
	x *= y // x = x * y (multiplica√ß√£o)
	x /= y // x = x / y (divis√£o)
	x %= y // x = x % y (resto)
	x **= y // x = x ** y (exponencial)
```
## Operadores l√≥gicos
### `!` Operador l√≥gico N√ÉO (NOT)
Se aplicado a um valor n√£o booleano, primeiro converte em booleano e depois torna ele o contr√°rio.
```javascript
let required = true;
console.log(!required) // false	
```

### `!!` Nega√ß√£o dupla (converter para boolean)
```javascript
let x = 10;
console.log(!!x) // true	
```
### `||` Operador l√≥gico OU (OR)
Retorna false somente se os dois valores forem falsos, se n√£o, retorna true;

| `a`| `b` |`a ou b` |
|---|----|----|
|true |true | true|
|true |false | true|
|false |true | true|
|false |false | false|

```javascript
let result = a || b;  // Se A for true, retorna A.
                      // Caso contr√°rio, retorna B
				
```
### `&&` Operador l√≥gico E (AND)
Retorna `true` somente se os dois valores forem verdadeiros

| `a`| `b` |`a && b` |
|---|----|----|
|true |true | true|
|true |false | false|
|false |true | false|
|false |false | false|

```javascript
let result = a && b; // Se A for true, retorna B.
// Caso contr√°rio, retorna A
```
### Curto-circuito

O operador `&&` est√° em curto-circuito, ou seja, avalia o segundo valor, apenas se o primeiro n√£o for o suficiente para determinar o valor da express√£o.
- Avalia valores da esquerda p/ direita
- Converte em booleano, se for `false`, interrompe a valida√ß√£o e retorna o valor 'falso'
- Se todos forem `true`, retorna o √∫ltimo valor
- Em outras palavras, o operador `&&` retorna o primeiro valor falso ou o √∫ltimo verdadeiro.
```javascript
let a = 10;
let b = 0;
let c = 'a''
let result = A && B && C; // 10 && 0 && 'a'
                          // true
                          // true && false -> INTERROMPE e retorna 0 

let result2 = 'a' && 'b'&& 'c' // todos s√£o true, retorna 'c' (o √∫ltimo)

//como usar no dia a dia?
required && validateFunction() // se required for true, vai chamar a fun√ß√£o
```

O operador `||` est√° em curto-circuito, ou seja, se o primeiro valor avaliado for `true` o operador n√£o vai avaliar o segundo valor.
- Avalia valores da esquerda p/ direita
- Converte em booleano, se for `true`, interrompe a valida√ß√£o e retorna o valor
- Se todos forem `false`, retorna o √∫ltimo valor 
- Em outras palavras, o operador `||` retorna o primeiro valor `true` ou o √∫ltimo valor.
```javascript
let a = 10;
let b = 0;
let c = 'a''
let result = A || B || C; // 10 || 0 || 'a'
                          // true -> INTERROMPE E RETORNA 10 
```

### Preced√™ncia l√≥gica do operador
Quando usamos v√°rios operadores em uma mesma express√£o, o JS avalia em uma ordem espec√≠fica.

- `* / %` multiplica√ß√£o, divis√£o, resto
- `+ - ` adi√ß√£o e subtra√ß√£o
- `< <= > >=` relacional
- `== != === !==` igualdade
- `!` n√£o
- `&&` e
- `||` ou

```javascript
let result = (true || false) && !false; // Retorna true
           // true && true
           // true
let result = true || false && !false; // Retorna true
          // true || false && true -> primeiro o !
          // true || false         -> segundo o &&
          // true 
```


#### <a name="hoisting"></a> Hoisting
Hoisting √© o i√ßamento de fun√ß√µes e vari√°veis para o topo do c√≥digo, isso declara as vari√°veis e fun√ß√µes em mem√≥ria e permite que voc√™ use uma fun√ß√£o/vari√°vel antes mesmo de declara-la.
```javascript
sayHello();
// a fun√ß√£o foi chamada antes de ser declarada
    
functionSayHello() {
    console.log("Say Hello");
}
```
O mesmo √© acontece para vari√°veis, as quais podem ser inicializadas antes de serem declaradas. Por√©m, o js eleva somente a declara√ß√£o n√£o a inicializa√ß√£o.
```javascript 
console.log(num); // undefined -> nesse caso num √© undefined porque s√≥ foi declarada
num = 6;
console.log(num); // 6 -> agora num j√° foi inicializada
var num;
```

####  <a name="scope"></a>Scope
Escopo √© a acessibilidade de objetos, vari√°veis e fun√ß√µes em diferentes partes do c√≥digo.

- Escopo Global
	- Uma vari√°vel global √© definida quando declaramos uma vari√°vel fora de qualquer fun√ß√£o, assim ela torna **acess√≠vel a qualquer parte** da nossa aplica√ß√£o ou site, podendo ser lida e alterada.

- Escopo Local
	- Uma vari√°vel se torna local quando ela √© declarada dentro de uma fun√ß√£o, de tal maneira a qual ela somente estar√° **acess√≠vel dentro dessa fun√ß√£o**.
	
- Escopo de bloco
	- N√£o existia no JS escopo de bloco. Ou seja, for whiles e ifs n√£o tinham escopo pr√≥prio. Por√©m com o ECMAScript 6 foi poss√≠vel criar escopos de bloco usando as vari√°veis **let** e **const**, que s√£o **acess√≠veis somente dentro do bloco.**

#### <a name="nested-scopes"></a> Nested Scopes

Todo o escopo √© fechado para acessos externos, de forma que escopos superiores n√£o conseguem acessar escopos internos, mas o contr√°rio √© permitido.

``` javascript 
function foo() {
    function bar() {
    
    }
}
```

Quando criamos outra fun√ß√£o dentro da fun√ß√£o foo, estamos colocando outra caixa dentro do escopo da fun√ß√£o, criando o que √© chamado de ‚Äúnested scopes‚Äù, ou escopos aninhados.


#### <a name="variables"></a> Variables (var, let e const)

![enter image description here](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/1ee22f2b-7f95-48ac-890a-04e836a28492/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200801/us-west-2/s3/aws4_request&X-Amz-Date=20200801T182119Z&X-Amz-Expires=86400&X-Amz-Signature=2f0cb6811c8cba5fd0103919a5856e514fdccdc8027343f324602c888251dd38&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22)

- Var 
	-    √© i√ßada
	-   tem escopo abrangente ‚Üí se for declarada dentro de um bloco ‚Üí vaza do escopo
	-   escopo global e fun√ß√£o ‚Üí n tem escopo de bloco
	- Praticamente n√£o s√£o mais usadas em aplica√ß√µes modernas devidos aos problemas de escopo ‚Üí **substitu√≠das por const e lets**
  
```javascript
function foo (a) {
  var name = 'Lucas'
  
  function bar () {
    var age = 23
    console.log(name) // Luca
    console.log(age) // 23
  }
  
  bar() // Lucas - 23
  console.log(name) // Lucas
  console.log(age) // age is not defined
}
```

```javascript
if(true) {
    var global = 2; // vaza de dentro do bloco
}

function teste() {
    var global = 4;
    console.log(global); //4
}

console.log(global); //2 -> acessa a que vazou do if
``` 

- Let e Const
	-   Tem escopo de **bloco** e de fun√ß√£o
	-  Sofrem hoisting (s√£o elevadas) para o topo do bloco que foram definidas ‚Üí por√©m n√£o √© atribuido o valor de undefined como acontece com var  ‚Üí continuam n√£o inicializadas e d√£o erro caso sejam chamadas antes de suas declara√ß√µes.
	- A grande diferen√ßa entre as duas √© que consts n√£o podem ser reatribu√≠das enquanto lets sim.

```javascript
function name() {
	console.log(name); // ‚ùå retorna erro porque ainda n√£o foi inicializada
	let name = 'isadora';
	console.log(name); // üëçüèº isadora
	name = 'isadora 2'; // üëçüèº pode ser reatru√≠da
}

const num = 6;
num = 8; // ‚ùå N√£o pode ser reatribu√≠da porque √© const

```
	
#### <a name="es6-features"></a> ES6 Features

- Declara√ß√£o de vari√°veis
- Default Parameters
- Rest parameters
- Programa√ß√£o funcional => arrow functions
- Destructing
- Classes (constructor, get/setters, heran√ßa (extends))
- Es6 Modules (import, export)

fonte: [https://medium.com/@matheusml/o-guia-do-es6-tudo-que-voc%C3%AA-precisa-saber-8c287876325f](https://medium.com/@matheusml/o-guia-do-es6-tudo-que-voc%C3%AA-precisa-saber-8c287876325f)

#### <a name="pure-functions"></a> Pure Functions
- Dada a mesma entrada, vai sempre retornar a mesma sa√≠da
- N√£o produz nenhum efeito colateral
```javascript
functions pureFunction(a,b) {
	return a + b;
} 
pureFunction(1,2) // retorna 3
 ```
 - Retorna sempre o mesmo valor baseado na entrada e n√£o manipula nenhuma vari√°vel de fora.
 - Porque usar?
	 - Mais f√°ceis de implementar e testar
	 - C√≥digo mais limpo, pr√°tico e de simples manuten√ß√£o
 
#### <a name="currying"></a> Currying
```Currying √© o nome dado √† t√©cnica de dividimos uma fun√ß√£o que recebe v√°rios argumentos numa s√©rie de fun√ß√µes cada uma lidando com **um** argumento da fun√ß√£o inicial.```

- Forma de injetar os parametros de forma parcial. 
- √â uma fun√ß√£o normal
- Faz parte de programa√ß√£o funcional
- Transforma uma fun√ß√£o com m√∫ltiplos argumentos em uma sequencia de nested functions (fun√ß√£o aninhada). Ela retorna uma fun√ß√£o que espera os pr√≥ximos argumentos.

```javascript
function somap(a) {
    return function(b) {
        return a+b
    }
}

// Uso:
var somadois = somap(2);
somadois(3); // 5
 ```
tamb√©m podemos executa-l√° de uma vez fazendo:
```somap(2)(3) // retorna 5 ```

tamb√©m pode ser escrita usando arrow functions: 
```javascript
const myFunction = valor1 => valor2 => valor3 => {
	return valor1 + valor2 + valor3;
}

console.log(myFunction(1)) // retorna a fun√ß√£o esperando o segundo parametro
console.log(myFunction(2)(4)(3)) // retorna 8
```

#### <a name="higher-order-functions"></a> Higher-Order Functions
- √â uma fun√ß√£o que **recebe como par√¢metro** outra fun√ß√£o e/ou que **retorna** uma fun√ß√£o
- Ex: map, reduce, filter..
 
```javascript
// calculate recebe como parametro uma fun√ß√£o
// calculate retorna uma fun√ß√£o
// Higher-Order function
var calculate = function(fn, x, y) {
	return fn(x, y);
};

var sum = function(x, y) {
	return x + y;
};

var mult = function(x, y) {
	return x * y;
};

calculate(sum, 2, 5); // 7
calculate(mult, 2, 5); // 10
 ```
usando ES6:
```javascript
const calculate = (fn, x, y) => fn(x,y);
const sum = (x, y) => x + y;
const mult = (x, y) => x * y;
calculate(sum, 2, 5); // 7
calculate(mult, 2, 5); // 10
 ```

#### <a name="closure"></a> Closure
- Closure √© a forma de fazer com que as vari√°veis dentro de uma fun√ß√£o sejam **privadas** e **persistentes**.
- Se refere √† forma como fun√ß√µes definidas dentro de um "contexto l√©xico" (i.e. o corpo de uma fun√ß√£o, um bloco, um arquivo fonte) acessam vari√°veis definidas nesse contexto.

```javascript
function pai(){  
   var x = 1;  
   function filho(){  
	  console.log(x);  
	  x++;  
   }  
   return filho;  
}  
  
var contador = pai();  
contador(); // 1  
contador(); // 2  
contador(); // 3
```
```A fun√ß√£o filho possui uma refer√™ncia ao escopo da fun√ß√£o pai, e a essa refer√™ncia n√≥s damos o nome de closure.```

- M√≥dulos s√£o estruturas de c√≥digo que fazem bom uso das _closures_, vamos a um exemplo que apresenta bem seu funcionamento:
```javascript
 function ModuloMatematico() {       
    var x = 0;      
    function somaUm() {  
        x++;          
        console.log(x);       
    }
    function subtraiUm() {           
        x--;  
        console.log(x);       
    }
	return {           
        somaUm: somaUm,           
        subtraiUm: subtraiUm       
    };   
}
var teste = ModuloMatematico();    
teste.somaUm();     // 1   
teste.somaUm();     // 2  
teste.somaUm();     // 3  
teste.subtraiUm();  // 2
```
Nesse exemplo, n√£o seria poss√≠vel acessar diretamente X, por√©m usando closures √© poss√≠vel fazer isso.
